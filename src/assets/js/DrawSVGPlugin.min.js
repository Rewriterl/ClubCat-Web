/*!
 * DrawSVGPlugin 3.1.1
 * https://greensock.com
 *
 * @license Copyright 2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports) : typeof define === 'function' && define.amd ? define(['exports'], t) : t((e = e || self).window = e.window || {}) }(this, function (e) { 'use strict'; function i () { return typeof window !== 'undefined' } function j () { return t || i() && (t = window.gsap) && t.registerPlugin && t } function m (e) { return Math.round(1e4 * e) / 1e4 } function n (e) { return parseFloat(e || 0) } function o (e, t) { return n(e.getAttribute(t)) } function q (e, t, s, r, i, o) { return P(Math.pow((n(s) - n(e)) * i, 2) + Math.pow((n(r) - n(t)) * o, 2)) } function r (e) { return console.warn(e) } function s (e) { return e.getAttribute('vector-effect') === 'non-scaling-stroke' } function v (e) { if (!(e = k(e)[0])) return 0; var t; var n; var i; var a; var f; var h; var d; var l = e.tagName.toLowerCase(); var u = e.style; var c = 1; var g = 1; s(e) && (g = e.getScreenCTM(), c = P(g.a * g.a + g.b * g.b), g = P(g.d * g.d + g.c * g.c)); try { n = e.getBBox() } catch (e) { r("Some browsers won't measure invisible elements (like display:none or masks inside defs).") } var _ = n || { x: 0, y: 0, width: 0, height: 0 }; var p = _.x; var x = _.y; var y = _.width; var m = _.height; if (n && (y || m) || !M[l] || (y = o(e, M[l][0]), m = o(e, M[l][1]), l !== 'rect' && l !== 'line' && (y *= 2, m *= 2), l === 'line' && (p = o(e, 'x1'), x = o(e, 'y1'), y = Math.abs(y - p), m = Math.abs(m - x))), l === 'path')a = u.strokeDasharray, u.strokeDasharray = 'none', t = e.getTotalLength() || 0, c !== g && r("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), t *= (c + g) / 2, u.strokeDasharray = a; else if (l === 'rect')t = 2 * y * c + 2 * m * g; else if (l === 'line')t = q(p, x, p + y, x + m, c, g); else if (l === 'polyline' || l === 'polygon') for (i = e.getAttribute('points').match(b) || [], l === 'polygon' && i.push(i[0], i[1]), t = 0, f = 2; f < i.length; f += 2)t += q(i[f - 2], i[f - 1], i[f], i[f + 1], c, g) || 0; else l !== 'circle' && l !== 'ellipse' || (h = y / 2 * c, d = m / 2 * g, t = Math.PI * (3 * (h + d) - P((3 * h + d) * (h + 3 * d)))); return t || 0 } function w (e, t) { if (!(e = k(e)[0])) return [0, 0]; t = t || v(e) + 1; var s = h.getComputedStyle(e); var r = s.strokeDasharray || ''; var i = n(s.strokeDashoffset); var o = r.indexOf(','); return o < 0 && (o = r.indexOf(' ')), t < (r = o < 0 ? t : n(r.substr(0, o)) || 1e-5) && (r = t), [Math.max(0, -i), Math.max(0, r - i)] } function x () { i() && (h = window, l = t = j(), k = t.utils.toArray, d = ((h.navigator || {}).userAgent || '').indexOf('Edge') !== -1) } var t; var k; var h; var d; var l; var b = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi; var M = { rect: ['width', 'height'], circle: ['r', 'r'], ellipse: ['rx', 'ry'], line: ['x2', 'y2'] }; var P = Math.sqrt; var a = { version: '3.1.1', name: 'drawSVG', register: function register (e) { t = e, x() }, init: function init (e, t) { if (!e.getBBox) return !1; l || x(); var r; var i; var o; var a; var f = v(e) + 1; return this._style = e.style, this._target = e, t + '' == 'true' ? t = '0 100%' : t ? (t + '').indexOf(' ') === -1 && (t = '0 ' + t) : t = '0 0', i = (function _parse (e, t, s) { var r; var i; var o = e.indexOf(' '); return i = o < 0 ? (r = void 0 !== s ? s + '' : e, e) : (r = e.substr(0, o), e.substr(o + 1)), r = ~r.indexOf('%') ? n(r) / 100 * t : n(r), (i = ~i.indexOf('%') ? n(i) / 100 * t : n(i)) < r ? [i, r] : [r, i] }(t, f, (r = w(e, f))[0])), this._length = m(f + 10), r[0] === 0 && i[0] === 0 ? (o = Math.max(1e-5, i[1] - f), this._dash = m(f + o), this._offset = m(f - r[1] + o), this._offsetPT = this.add(this, '_offset', this._offset, m(f - i[1] + o))) : (this._dash = m(r[1] - r[0]) || 1e-6, this._offset = m(-r[0]), this._dashPT = this.add(this, '_dash', this._dash, m(i[1] - i[0]) || 1e-5), this._offsetPT = this.add(this, '_offset', this._offset, m(-i[0]))), d && (a = h.getComputedStyle(e)).strokeLinecap !== a.strokeLinejoin && (i = n(a.strokeMiterlimit), this.add(e.style, 'strokeMiterlimit', i, i + 0.01)), this._live = s(e) || ~(t + '').indexOf('live'), this._props.push('drawSVG'), 1 }, render: function render (e, t) { var n; var s; var r; var i; var o = t._pt; var a = t._style; if (o) { for (t._live && (n = v(t._target) + 11) !== t._length && (s = n / t._length, t._length = n, t._offsetPT.s *= s, t._offsetPT.c *= s, t._dashPT ? (t._dashPT.s *= s, t._dashPT.c *= s) : t._dash *= s); o;)o.r(e, o.d), o = o._next; r = t._dash, i = t._offset, n = t._length, a.strokeDashoffset = t._offset, e !== 1 && e ? a.strokeDasharray = r + 'px,' + n + 'px' : (r - i < 0.001 && n - r <= 10 && (a.strokeDashoffset = i + 1), a.strokeDasharray = i < 0.001 && n - r <= 10 ? 'none' : i === r ? '0px, 999999px' : r + 'px,' + n + 'px') } }, getLength: v, getPosition: w }; j() && t.registerPlugin(a), e.DrawSVGPlugin = a, e.default = a; if (typeof (window) === 'undefined' || window !== e) { Object.defineProperty(e, '__esModule', { value: !0 }) } else { delete e.default } }))
// # sourceMappingURL=DrawSVGPlugin.min.js.map
